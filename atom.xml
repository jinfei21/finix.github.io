<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>金飞的个人博客</title>
  
  <subtitle>上善若水，知行合一</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jinfei21.github.io/"/>
  <updated>2018-05-18T16:08:55.437Z</updated>
  <id>https://jinfei21.github.io/</id>
  
  <author>
    <name>费永军</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中国思想演变启示录</title>
    <link href="https://jinfei21.github.io/2018/05/18/%E4%B8%AD%E5%9B%BD%E6%80%9D%E6%83%B3%E6%BC%94%E5%8F%98%E7%AE%80%E4%BB%8B/"/>
    <id>https://jinfei21.github.io/2018/05/18/中国思想演变简介/</id>
    <published>2018-05-18T12:41:25.000Z</published>
    <updated>2018-05-18T16:08:55.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>&emsp;&emsp;最近终于断断续续把《枢纽》这本书看完了，完美解释了我一直以来的疑问。以前看历史的时候，一直很奇怪，为什么先秦之前华夏族能傲视四夷？而后来几千万汉人干不过几百万游牧民族？施展老师从大格局和技术进步的角度，完美解释了中国近三千年的阶层演化史。非常的精彩，令人读之神清气爽，真有种朝闻道夕死可矣的感觉。我今天想从另外的角度谈谈中国人思想的演化史。为什么要谈思想演化史？是因为当今时代变化太快，搞的我们中国目前大部分中产都很焦虑，同时还有一波靠向中产贩卖焦虑挣钱的人。动不动就时代抛弃你连再见都不会和你说，又被同龄人甩多远了等等。我就想看看以前古人以前是不是也和我们遇到相同的问题，因为现在的我们终将是历史的古人。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&emsp;&emsp;我们学习中国历史，学的东西很多，比如说分分合合，王朝更替，兴衰成败，实际上什么都没有看的很清楚。其实中国历史一句话就概括了，那就是“文明主导，文明融合和文明奔溃，文明新生的一个历史”。因为这种文明的崩溃导致了中国历史上两次巨大的灾难。围绕这两次灾难，中国历史可以划分为三个千年。</p><p>&emsp;&emsp;甲骨文之前，商代以前的太遥远，文字记载的太少传说比较多，文化上也不是太清楚，姑且搁置不论。从周到东汉末期，这个差不多一千年；然后从东汉末期到宋朝差不多一千年；第三个就是从宋朝到晚清，刚好差不多又是一千年。</p><p>&emsp;&emsp;中国古代的主导思想-（儒家思想）形成是在春秋战国时期，但是真正成为官方的主导价值观是在汉初第五代皇帝，由汉武帝的董仲舒完成了大统一。这个时候儒家只是为了王朝统治的需要，同时也是中国传统农耕社会需要。董仲舒把儒家进行包装和改变，变得既不是孔子的那个儒家，也不是孟子的那个儒家，同时也不是荀子那个儒家。他提出了一种“天人合一，阴阳五行”很奇怪的东西，理论倒是不复杂，就是上天和地上的人是一个样的，我们表现不好老天是知道的，如果皇帝做了坏事上天会惩罚，惩罚的方式就是降天灾，比如洪水，春天下雪，蝗虫灾害，地震，饥荒等等。只要有这些天灾发生，那就是上天对你的警示，说明你的仁政没有做好。</p><p>&emsp;&emsp;这套理论主要是给无上的皇权套一个紧箍咒，毕竟天灾不是经常发生，皇帝也不敢太放肆，必须有所收敛施行仁政。这套理论一直运行到东汉末期之前都是ok，没有任何人怀疑。但是到了东汉末年出现了巨大问题，就是皇帝无论怎么做天灾都不可避免。有科学家对这个时期的太阳黑子做了统计，当时处在太阳黑子最活跃期，每年都有巨大灾害，这样一来，皇帝无论干什么，做了多少善事，施行了多少仁政，包括处罚大臣都没有用。这个时候，大家开始怀疑，崩溃，没有办法了。儒家在这个时候遇到第一次危机，崩溃。儒生不在相信天人合一的儒学，皇帝也不相信了。造成东汉末年之后将近四百年的中国大崩溃，大混乱。出现了十室九空的恐怖场景，人要不就是被杀掉，要不就是战乱中死掉。所以三国演义很精彩，其实那是最悲惨的一段时间。</p><p>&emsp;&emsp;这个时期的儒生开始自暴自弃，既然追求修身养性，兼济天下都没有办法，那就随波逐流自暴自弃。著名的竹林七贤就天天喝酒，进行各种行为艺术，比如同性恋，光着身体喝酒，很变态。因为他们觉得活在这个世界上追求的东西没有了，活着没有意义。就有点像西方社会上帝已死的感觉。这个时候在汉末，汉末魏晋时期就面临这种境况。常常听一些红学家说什么魏晋风度，基本是没有历史常识。任何人都不会严肃对待一个乐自逍遥的人。</p><p>&emsp;&emsp;魏晋时期这个时候玄学开始流行，天天空谈一些老子，庄子。要怎么保养自己的身体，这个时候的道家炼丹术特别流行，著名的“竹林七贤”就是丹药吃多了，早早慢性中毒死掉了。一个国家精英在追求这些东西，这个社会会变成什么样子？之所以玄学这个时候兴起，是因为大家看到身边的人都死了，当时从五千多万人死到只剩几百万人，打个折算一千万，五个人就有一个死了。曹操的军粮是什么？人肉干。曹操说“白骨露于野,千里无鸡鸣。生民百遗一，念之断人肠”，这绝对不是夸张，这是纪实报道，真的是白骨露于野，千里无鸡鸣。这些精英看到人很容易死了，他们自己也不知道明天在哪里。而且偏偏这个时候佛教开始传入中国。</p><p>&emsp;&emsp;佛教倡导的“空”，老子是“无”，庄子是“自然”。当这三者结合在一起，这边有面临着儒学经世致用价值信念崩溃，所以这个时候儒生都投入到空无的那套东西中去了。从魏晋一直到唐朝，佛教都一直很繁荣。“南朝四百八十寺，多少楼台烟雨中”，就是讲那个时候，这种魏晋玄学和佛学，为他们提供了人生的归宿。活着的意义不再是儒家了，而是老子的“无”与佛教的“空”。</p><p>&emsp;&emsp;当这些价值在精英中兴起，问题就大了。佛教崇尚的是轮回、是空、是缘，而儒家强调的是三纲五常，强调的是血缘关系，推己及人这些东西，社会的核心价值基础是家，由家而国，如果一切都是无和空，家还有什么意义呢？从佛教来说，家是没有意义的，因为缘聚缘散，你是因为缘才聚到一起的，他们才成为你父母，你妻子，成为你子女的。儒家强调的这些东西还有意义吗？儒家强调的是血缘、伦理，由伦理关系推到亲戚关系，再由亲戚关系推到族人关系，由家的关系上升到国的关系，所以才叫“国家”嘛。国是一个大家，家是一个小国，是这种关系。如果从佛教、老子角度来说，这些是没有意义的。所以这时候，这些文化人不再去追求治理国家了，不再问今生的社会怎么样了，跟我没有关系了，我只求及时行乐就好。所以这就导致东汉末之后一直到隋唐前的社会大分裂。</p><p>&emsp;&emsp;到了第二阶段，现在一说起唐朝好像很牛，其实大唐从他建立的那刻起就埋着分裂的种子。这个时候，佛教，道教和儒家是并行的，并没有谁占主导地位。虽然儒学是唐朝的官学，但是儒学这个时候不是特别都待见。唐朝的社会精英实际上非常焦虑，非常有危机感。表面上看，唐朝社会文化非常发达，比如波斯明教，伊斯兰教，基督教以及后来给清朝造成巨大冲击的白莲教这个都是都有，虽然很发达，但是隐藏着巨大危机，这时候进入到中国历史上第二个大分裂期—五代十国。</p><p>&emsp;&emsp;五代十国实际上是从安禄山、史思明的“安史之乱”开始的，安禄山是胡人，很多也都是胡人，但是他是唐玄宗的爱将，权重一方，从这里可以看出唐朝的社会是建立在“五胡乱华”大分裂之后的基础上的。“安史之乱”以后就是“藩镇割据”，就是每个拥有实力的将军他可以割据一方，这种事情在中国统一的王朝上是绝对不允许出现的，包括刘邦和他子孙的王朝，就连同姓王割据也不允许。</p><p>&emsp;&emsp;汉高祖把韩信这些异姓王干掉了，同时他的子孙又把同姓王又干掉了。中国以前是长子继承制，汉朝为了改变地方诸侯做大、威胁中央政权的这种事情，它就搞了一个“推恩令”。因为都是刘姓的皇室家族的嘛，所以诸王的妻子、孩子肯定特别多。假设一个诸侯国王他有几十个孩子，中央就告诉他不能把诸侯国传给你的长子，你要平均分配给你那些孩子，这就叫“推恩令”。这样几十个孩子都分下去了，每个孩子的孩子也都不是省油的灯，他也有几十个孩子，这样一直分下去的话，数学上你分分就知道了，诸侯国肯定是四分五裂，越变越小，变到最后可能就是没落的一个小地主家庭了，对中央是毫无威胁了。</p><p>&emsp;&emsp;但是在唐朝末年，因为文化没有融合，这种东西又出现了，那就是从“藩镇割据”演变到五代十国。直到周世宗柴荣，其实他也是五代十国的一个政权，他灭了很多大大小小的国，后来是赵匡胤黄袍加身取代了柴家，他也灭掉很多分裂的政权，这才结束五代十国这样一个大分裂。</p><p>&emsp;&emsp;这时候到了宋朝，宋朝完成了传统儒学对佛学的消化。它把佛学变成了自己的一部分，构建起一种新的儒家精神，重新诠释了儒学的内涵，这就是新儒学。新儒学不是今天贩卖国学的人搞的那套东西，它是指宋代那些大宗师的学说。这时宋朝社会重拾对儒家的信心，人生的意义不再是空，也不是无，而是从新有了现实的意义。包括后来明朝王阳明心学，其实也是从宋朝的程朱理学，陆王心学发展起来的。</p><p>&emsp;&emsp;程朱理学是以程颐、程颢和朱熹为代表的。他们提出的这种修身的办法叫做“天理”，天理是存在的，他们就说人生的终极意义是为了追求天理，所以他提出一个著名的口号叫“存天理、灭人欲”。天理是什么呢？就是仁。为什么天会有仁呢？这个宇宙怎么会有人间的“仁”呢？另外一个人对此进行了补充，这个人叫张载。张载说宇宙是由气构成的，气一动就会产生很多的东西，一个东西叫物质，一个东西叫情感。气的本性就是万物的本性，当然也包括人。他又认为人具有先天之性，也就是天地之性，诚明纯清，是善的来源；但人也受各种天地环境与社会环境的影响，又形成了后天之性，也叫“气质之性格”，有清有浊，有善有恶……所以人就应该通过后天的修身，让天性之中的至善呈现出来。所以我跟宇宙是一样的，宇宙也有天理、也有感情。张载有一句话非常嚣张，叫做“为天地立心，为生民立命，为往生继绝学，为万世开太平”</p><p>&emsp;&emsp;另外一个叫做陆九渊，这个人跟朱熹是同一个时代，他们还曾经辩论过，当然他们实际上都是属于一类的，只不过是又分成了派，分成了不同的路径，就不去细讲了。陆九渊就提出来，我心就是宇宙，宇宙就是我心。后来的王阳明就是在陆九渊的基础上发展出来的。</p><p>&emsp;&emsp;归纳来说，程朱理学它回答了几个东西：我在今生的意义是什么？我与宇宙的关系是什么？我与别人的关系是什么？宋代也是中国可能可以跟春秋时候相媲美的一个时期，思想家特别的多。为什么宇宙跟我有关系？先由周敦颐提出了《太极图说》，他提出了一个“宇宙观”，经过一代一代的努力，几代人不停地总结、努力，终于消化了佛学，包括道家对儒学的挑战。今天说儒家的《四书五经》，《四书》是在宋朝由朱熹提出来的，并不是春秋的时候孔子或者是汉朝的时候大一统提出来的。《大学》、《论语》、《中庸》、《孟子》这四书，是在宋朝有朱熹提出来的，因为宋完成了儒学又一次正统地位的塑造。</p><p>&emsp;&emsp;宋明理学消化了佛教、道家，但是也造成了另外一个巨大问题。既然宇宙跟我有很多关系，为了完成人生的终极意义，就要做两件事情，第一件事情是冥想、静观，要去想宇宙的天理是什么；第二件事是明白宇宙的这个东西，印证到我读的儒家经典，我才明白儒家的“礼”，才能用这种“礼”学去修齐治平。</p><p>&emsp;&emsp;看起来是很简单的一个东西吧？但是实行起来会出现很多的问题。以佛教打比方，放下屠刀、立地成佛是吧？但是有些人放下屠刀后，他确实是成不了佛啊。因为有很多人的悟性、理解力很多时候过不了这一关。他悟不透，想不通啊，你看连王阳明这样聪慧的人都“格物”、格了七天的竹子，他都格出毛病来了，别人又会如何呢？</p><p>&emsp;&emsp;对天理的思考无法迈过这一关，就致使很多儒生一辈子不是去干实事，而是就是在那儿想、在那儿观照、在那儿静思。这导致后面的知识分子很多都是务虚派，也就是不干实事，再也汉唐儒学家干实事的做法，整天就是空谈。平时袖手谈心性，临时一死报君王。一个人出问题，不是说这个事情没有做好，而是说他的心有问题，道德有问题，然后就是泛道德化攻击，个个都是圣母婊。</p><p>&emsp;&emsp;因为宋明理学的导致的务虚空谈。导致我的老乡张居正的悲剧。这个人本来可以挽救明朝的。明朝的税收特别复杂，，比如说你家种茶叶，你怎么交税呢？交茶叶。税收之外，还有各种徭役，比如说要干苦活的、出民工的这种徭役，很复杂。所以张居正有一个理财办法像今天一样交企业税就好了，交钱就好了。这是非常好的办法，我们想想都知道，比如说我家种茶叶我交上去的税收是茶叶，这是不是会很成问题？茶叶会发霉；茶叶要运到中央库府里面要有人去运。同样粮食要有人运，粮食从大运河运到北京可能一半的粮食必须被吃掉，不然那么远的地方就运不到啊，那些船工和保护的大兵都需要去吃饭的啊。张居正提出“一条鞭法”，税收都用钱来交，这是非常好的办法，也是行之有效的，但是他失败了。就是因为明朝很务虚。因为大家用道德抨击他这个人，一个人要抨击一个人不是抨击这个事情，而是攻击他的道德，这就是泛道德化。这种现象在今天也很常见，就是给别人扣大帽子，这种做法是很逆人性的。人是复杂的，他可能做错事，有一些还可能还是原则性错误，但是他也有可能做了一些有实际价值的事情，怎么可能都是绝对化的呢？中国传统文化里边，攻击一个人常常不是说他做错了什么事，而是先扣大帽子，说他道德有问题。到了张居正这个明朝时，正是程朱理学实行得最深入的时期，所以张居正非常好的改革，能够延缓大明王朝衰落时间的“一条鞭法”完蛋了。这是非常愚蠢的。你知道吗？先秦的人们可不是这样的，先秦的文明里没有这么愚蠢的思维方式。你看商鞅变法，商鞅被秦国贵族诛杀了，但是商鞅的改革被保留下来了。当张居正死了以后，万历就对他进行了抄家，把张居正所有的做法全部推翻了。滑稽的是，明朝“一条鞭法”这么好的改革办法却在清朝开花结果了，清朝一个叫“摊丁入亩”的税收办法实际上就是在张居正基础上略加升级的，实际上是把张居正的“一条鞭法” 2.0版，这么稍微改了一下就迎来了康乾盛世。这是一个好方法，却因为明朝务虚、泛道德化而没有继承下去。</p><p>&emsp;&emsp;到了明末清初的时候会看到一个现象，明末清初的那些人又再一次非常反感程朱理学、陆王心学。他们进一步思考，因为我们知道宋朝是被元朝灭掉的，为什么宋朝的知识群体会接受元朝呢？因为当时宋朝人程朱理学还没有实行那么深入，刚刚是在创立出来，还没有彻底深入，所以在儒学观念里面，特别是孟子讲的，施行仁政的皇帝就配当皇帝，如果不施行仁政的皇帝应该被更替掉。宋朝知识分子认为宋朝皇帝没有施行仁政，导致被蒙古人替代了。所以他们就希望协助蒙古人施行仁政，所以就接受它了，只不过是又换了一个治理者而已，儒学的正宗、华夏文明的正统还在的。但是明朝大家就不这样想了。</p><p>&emsp;&emsp;明朝知识分子他们不是觉得亡国了，顾炎武觉得亡天下了，天下就是指中华文明，中华文明是被满清野蛮人给吞并了。满清人都是很野蛮的，他们叫做“留发不留头”，大肆屠杀。如果你不留辫子，不剃头发，儒家讲“身体发肤，受之父母”，是不可以把它剪掉的，因为那些满族人为了骑马、射箭方便，头发在前边飘来飘去射箭打仗不方便，所以他把前面剃掉、扎个辫子很方便，但是到了中原要求中原所有的男人儒生都这么做，那些儒生认为这就是野蛮人对我的奴役，他们就不这么干，不这么干就被杀死，所以叫“留头发可以，头就不要留了”，他们认为这样是野蛮人对中原的践踏，是儒学正统的沦陷，是华夏文明亡了，是亡天下。</p><p>&emsp;&emsp;明末清初几个著名的哲学家，顾炎武，王夫之，黄宗羲，他们都是干实事的。顾炎武是明朝遗民，做调查研究，把祖国的山山水水，哪里是军事要地，哪里的水利要兴修，他干这些调查研究去了；王夫之更是一生反清复明，一直践行着到死，就是誓不投降……清初的这些哲学家其实为我们近代文明的开端提供了巨大的思想资源。假设我们是明朝被西方入侵的话，那么我们今天可能就不会是这样的局面了，我们的危机大概会更深重。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>&emsp;&emsp;思想演化就介绍到这了，整体脉络大概梳理清楚了。我为什么喜欢看历史？曾经有一个教授说中国古代史不要多学，因为没用，要学世界史和近代史。其实这个完全是胡说八道。如果真正读懂历史，就会知道历史不是看历史事实，而是看历史逻辑。如果从逻辑来看，今天和唐初差不多。我们今天引入西方的马克思主义，改革开放又引入西方的市场制度，我们的文化很繁荣，但是我们的心灵很饥渴很焦虑，现在的传统儒家文化就面临着消化不同文明，大融合的问题。</p><p>&emsp;&emsp;我们看到今天为什么会有一些焦虑、彷徨、困惑，其实我们今天每个人都是笑傲江湖里的令狐冲，因为我们今天既不是生活在传统的儒家社会，也不是以前的革命年代，现在是经济建设年代。但我们也不是西方人，我们也不可能去接受全盘西化，我们是黄皮肤、黑头发。现实就是我们不可避免地受到几千年传统儒家文化的影响，这是我们此身上被输入的第一股内力，这个最雄浑的内力输入在我身上，尽管你看起来好像跟它没有关系，但实际上它又潜移默化，比如说清明节扫墓，你回家扫墓，追思慎远，这些它都是中国传统的一些东西，它是根深蒂固的。它不可能因为某一次运动而消失。第二个我们也不再是完全的革命年代了，农业学大寨也好，人民公社也好，这都是过去时了，我们已经不是革命的年代。我们也取得了巨大的成就，我们现在是以社会主义经济建设为主。但第三个，我们同时又不可避免地受到西方文化的入侵，或者说用一个中性的词就是西方文化的传入，西学东渐，西方的很多生活方式与价值观我们不可避免地受到它的一些影响。</p><p>&emsp;&emsp;所以我们今天在社会上看到很多的一些文化贩卖者的表现，当然我很尊敬他们事业上的成功，但实际上他们输出的价值都是一些什么东西呢？都是一些成功学、一些片断、一些碎片，是找不到根的，你在他们身上找不到根，他们连自己都没有一个文化的信仰，能贩卖的也只有些瞎唬人的东西。读书两个东西就够了，一个是根的，一个是专业的，书到今生读已迟，你却还瞎读八读的，不是浪费余生时光吗？所以我们才会被眼前的各种热，一会儿国学热，一会儿又有什么辟谷，一会儿又远方啊诗啊，被各种各样的“热”所主导、所摇晃，觉得哪个也不能错过，不然就被时代抛弃了，可是搞了半天，你真能解决内心的那些慌张吗？这就是因为我们没有明白或者说没有看清实质。这些热、那些热的背后的东西，实际上我认为它的赚钱、功利目的远远大于它寻找的意义。</p><p>&emsp;&emsp;我们的心灵需要一个出口，现代化既不是电灯电话吃西餐，也不是异国他乡找到归宿，也不可能在儒家之外找到归宿。那些有志于修齐治平，以天下为思考出发点的儒家研究者，面临着消化马克思主义和西方文明的问题，儒家需要像宋明理学家那样重新出发，为我们提供一个人生的终极意义。这个需要几代人努力去融合，我相信总会有思想家出来为我们立心的。儒家的农耕文明，儒学的很多东西是有问题的，但并不代表着它没有光芒。</p><p>&emsp;&emsp;我的思想转变去年特别大，其实我是比韩寒更早从叛逆回归传统的。他说“知道很多道理，依然过不好这一生”，这句话一时成了流行语。其实因为知道了很多道理，实际等于没道理，那些东西都是小道理，都是鸡汤，没有儒家那种止于至善那种大道理在，类似美国那些顶级企业级的清教徒思想，他们要把他们的一切努力归于对上帝的奉献，而我们应该是儒家新的大融合之后的终极人生意义，我们应该有这样一种心灵归途。为什么一方面鸡汤被大家嘲讽，但一方面鸡汤又很流行，创造了很多的一些社会现象呢？是因为我们内心饥渴啊！有饥渴才有鸡汤。如果我们有一个终极的人生意义，心灵牧场里就不会养鸡，鸡汤也没容身之地，大家会知道这种东西是很搞笑的，是很小儿科的，是怪力乱神……所以我们今天不要嘲笑高大上，高大上没有什么可嘲笑的。值得嘲笑的是高大上的缺失。正是因为没有以大、上为出发点的东西，才没有发上等愿、择高处立的风气，我们才有很多的精致利己主义、才有很多的犬儒主义，才有很多的为了眼前利益而什么都不在乎、一再越过人性底线的现象。</p><p>&emsp;&emsp;最后总结一下：尔曹身与名俱灭，不废长江万古流，一千年呢其实只是一瞬间。我们今天活一百岁也好，八十岁也好，实际上在中国的两千年，我们只是两千年两次文明破与立之间的一个尘埃而已。我们要看到自己所处在的历史里面的坐标，从最初到现在就是文明的一个衰落、融合以及我们面临的再融合问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近终于断断续续把《枢纽》这本书看完了，完美解释了我一直以来的疑问。以前看历史的时候，一直很奇怪，为什么先秦之前华夏
      
    
    </summary>
    
      <category term="历史" scheme="https://jinfei21.github.io/categories/%E5%8E%86%E5%8F%B2/"/>
    
    
      <category term="历史" scheme="https://jinfei21.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>心经</title>
    <link href="https://jinfei21.github.io/2018/04/26/%E5%BF%83%E7%BB%8F/"/>
    <id>https://jinfei21.github.io/2018/04/26/心经/</id>
    <published>2018-04-26T11:24:37.000Z</published>
    <updated>2018-05-18T12:33:41.802Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<font color="DarkBlue" size="10">观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。舍利子，色不异空，空不异色，色即是空，空即是色，受想行识，亦复如是。舍利子，是诸法空相，不生不灭，不垢不净，不增不减。是故空中无色，无受想行识，无眼耳鼻舌身意，无色声香味触法，无眼界，乃至无意识界，无无明，亦无无明尽，乃至无老死，亦无老死尽。无苦集灭道，无智亦无得。以无所得故。菩提萨埵，依般若波罗蜜多故，心无挂碍。无挂碍故，无有恐怖，远离颠倒梦想，究竟涅盘。三世诸佛，依般若波罗蜜多故，得阿耨多罗三藐三菩提。故知般若波罗蜜多，是大神咒，是大明咒，是无上咒，是无等等咒，能除一切苦，真实不虚。故说般若波罗蜜多咒，即说咒曰：揭谛揭谛，波罗揭谛，波罗僧揭谛，菩提萨婆诃。</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;DarkBlue&quot; size=&quot;10&quot;&gt;观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。舍利子，色不异空，空不异色，色即是空，空即是色，受想行识，亦复如是。舍利子，是诸法空相，不生不灭，不垢不净，不增不减。是故空中
      
    
    </summary>
    
      <category term="佛学" scheme="https://jinfei21.github.io/categories/%E4%BD%9B%E5%AD%A6/"/>
    
    
      <category term="佛学" scheme="https://jinfei21.github.io/tags/%E4%BD%9B%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>kong源码导读</title>
    <link href="https://jinfei21.github.io/2018/04/16/20180416/"/>
    <id>https://jinfei21.github.io/2018/04/16/20180416/</id>
    <published>2018-04-16T07:24:37.000Z</published>
    <updated>2018-05-18T12:33:41.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>&emsp;&emsp;kong是一个基于nginx和OpenResty模块构建的API网关服务。提供http请求路由，后端服务负载均衡以及通过丰富的插件提供认证鉴权、流量调控、日志监控等功能。该网关目前应用在全球著名的API管理站点<a href="https://market.mashape.com/explore?page=1" target="_blank" rel="noopener">mashape</a>上。<br>&emsp;&emsp;nginx是一个采用异步I/O，事件驱动的高性能Web服务器，也可以作为在企业内部提供基于http rpc的反向代理和负载均衡器。由于nginx的配置都是以静态文件的方式提供，而且nginx一般都是多台部署，导致nginx的运维管理变得比较复杂。许多运维的小伙伴都会写一些运维脚本，自动通过ssh命令远程连接到服务器去做一些配置更新的操作。<br>&emsp;&emsp;笔者所在公司也开发过一个基于nginx的软负载中心。用户可以在平台上为自己的服务配置反向代理以及负载均衡策略。用户所有的操作都会打包成一次对nginx配置的修改。修改指令会发送到每台nginx部署的一个agent上，最后由agent完成nginx配置文件的更新。<br>&emsp;&emsp;这些方法虽然可以达到自动化的管理nginx，但是本质上还是通过配置文件的方式去改变nginx的一些固定行为。在企业里面，特别是互联网公司常常需要定制一些功能。虽然可以为nginx开发一些模块，但是门槛较高，需要对nginx源码级的掌握。OpenResty为nginx引入的LuaJIT和lua-nginx-module，使我们可以在nginx的各个执行阶段编写一些lua脚本，极大地扩展了nginx的功能。OpenResty的作者已经用lua开发了许多工具库，使得我们可以在nginx中访问MySQL、Memcached、Redis。kong在此基础上实现了一个API网关服务。</p><a id="more"></a><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><h3 id="如何阅读源码"><a href="#如何阅读源码" class="headerlink" title="如何阅读源码"></a>如何阅读源码</h3><p>&emsp;&emsp;想必看这边文章的许多朋友之前对nginx都略有了解，但是可能是头一次接触lua语言，笔者当时也是头一次。这种情况笔者一般不会一上来就去阅读源码，而是先阅读下官方文档，把环境搭建起来之后试用下功能，然后看下日志。这样会对这个系统有个整体的感觉，之后就可以去翻翻源码了。笔者所使用的编辑器是IntelljIDEA，它可以自动识别出lua语言，然后提示你去下载支持该语言的插件，很是方便。笔者全程是在ubuntu环境下开发的，使用linux系统的好处是改完代码后执行下make命令，然后reload下nginx就可以看到效果。使用windows的童鞋建议装个linux的虚拟机。由于调试kong比较麻烦，所以笔者都是通过加日志的方式学习代码的。选取一些关键的流程打印一些数据会对源码的学习起到事半功倍的效果。有时候在troubleshooting的时候更加需要打印许多日志才能把问题定位到。<br>&emsp;&emsp;笔者使用的kong的版本为0.12.1</p><h3 id="如何使用该文档"><a href="#如何使用该文档" class="headerlink" title="如何使用该文档"></a>如何使用该文档</h3><p>&emsp;&emsp;本文档作为源码导读，在阅读本文档时手头最好有一份kong的源码以便随时进入源码深入阅读。读者不必从头到尾进行通读，可以根据目录选择自己感兴趣的章节进行阅读。</p><h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><p>|– kong<br>&emsp;&emsp;|– api [admin管理接口的代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– cluster_events [集群事件的数据访问层代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– cmd [kong命令行的代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– core [请求处理、路由、负载均衡等核心代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– dao [数据库访问层代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– plugins [插件的代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– templates [nginx配置文件模板]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– tools [工具类代码]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– vendor [这里提供了用于lua面向对象编程的基类]<br>&emsp;&emsp;&emsp;&emsp;|– …<br>&emsp;&emsp;|– cache.lua [缓存实现类，封装了mlcache]<br>&emsp;&emsp;|– cluster_events.lua [集群事件同步代码]<br>&emsp;&emsp;|– conf_loader.lua [配置加载]<br>&emsp;&emsp;|– constants.lua [常量定义]<br>&emsp;&emsp;|– init.lua [kong的入口，可以从这里开始阅读代码]<br>&emsp;&emsp;|– meta.lua [定义版本号之类]<br>&emsp;&emsp;|– mlcache.lua [封装了lua-resty-mlcache]<br>&emsp;&emsp;|– singletons.lua [单例模式，存放公共对象]  </p><h3 id="执行入口"><a href="#执行入口" class="headerlink" title="执行入口"></a>执行入口</h3><p>&emsp;&emsp;以下是kong的nginx配置文件，笔者把一些和本章主题无关的先去掉了。  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">init_by_lua_block &#123;</span><br><span class="line">    kong = <span class="built_in">require</span> <span class="string">'kong'</span></span><br><span class="line">    kong.init()</span><br><span class="line">&#125;</span><br><span class="line">init_worker_by_lua_block &#123;</span><br><span class="line">    kong.init_worker()</span><br><span class="line">&#125;</span><br><span class="line">upstream kong_upstream &#123;</span><br><span class="line">    server <span class="number">0.0</span><span class="number">.0</span><span class="number">.1</span>;</span><br><span class="line">    balancer_by_lua_block &#123;</span><br><span class="line">        kong.balancer()</span><br><span class="line">    &#125;</span><br><span class="line">    keepalive <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    server_name kong;</span><br><span class="line">    listen <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span>;</span><br><span class="line">    location / &#123;     </span><br><span class="line">        rewrite_by_lua_block &#123;</span><br><span class="line">            kong.rewrite()</span><br><span class="line">        &#125;</span><br><span class="line">        access_by_lua_block &#123;</span><br><span class="line">            kong.access()</span><br><span class="line">        &#125;</span><br><span class="line">        header_filter_by_lua_block &#123;</span><br><span class="line">            kong.header_filter()</span><br><span class="line">        &#125;</span><br><span class="line">        body_filter_by_lua_block &#123;</span><br><span class="line">            kong.body_filter()</span><br><span class="line">        &#125;</span><br><span class="line">        log_by_lua_block &#123;</span><br><span class="line">            kong.<span class="built_in">log</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    location = /kong_error_handler &#123;</span><br><span class="line">        internal;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            kong.handle_error()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到kong的代码执行入口在init_by_lua_block块中，该块中的代码会在nginx的master加载配置的时候被执行。通过require ‘kong’得到的实例是一个全局对象，在Lua虚拟机里面执行的代码都可以访问到。<br>该实例通过master的fork进程方法共享给worker，如果worker修改该实例会触发操作系统进程的copy-on-write，worker进程就会拥有该实例的一个副本。<br>&emsp;&emsp;后缀是by_lua_block的都代表nginx处理请求的一个执行阶段，每个阶段都会执行相应的kong代码。nginx执行阶段流程如下如所示:  </p><p><img src="/2018/04/16/20180416/openresty_phases.png" alt=""></p><ul><li>init_by_lua*<br>&emsp;&emsp;发生在master进程启动阶段。这里会对数据访问层进行初始化，加载插件的代码，构造路由规则表。  </li><li>init_worker_by_lua*<br>&emsp;&emsp;发生在worker进程启动阶段。这里会开启数据同步机制，执行每个插件的init_worker方法。  </li><li>set_by_lua*<br>&emsp;&emsp;处理请求第一个执行阶段。这里可以做一些流程分支处理判断变量初始化。kong没有使用该阶段。</li><li>rewrite_by_lua*<br>&emsp;&emsp;这里可以对请求做一些修改。kong在这里会把处理代理给插件的rewrite方法。  </li><li>access_by_lua*<br>&emsp;&emsp;kong在这里对请求进行路由匹配，找到后端的upstream服务的节点。  </li><li>balancer_by_lua*<br>&emsp;&emsp;kong在这里会把上一阶段找到的服务节点设置给nginx的load balancer。如果设置了重试次数，此阶段可能会被执行多次。  </li><li>header_filter_by_lua*<br>&emsp;&emsp;这里可以对响应头做一些处理。kong在这里会把处理代理给插件的header_filter方法。  </li><li>body_filter_by_lua*<br>&emsp;&emsp;这里可以对响应体做一些处理。kong在这里会把处理代理给插件的body_filter方法。  </li><li>log_by_lua*<br>&emsp;&emsp;kong在这里会通过插件异步记录日志和一些metrics数据。  </li></ul><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>&emsp;&emsp;kong有三大核心模块：请求路由(Router)、负载均衡(Balancer)和集群数据同步。这3个模块加上插件就组成了kong的所有功能。<br>&emsp;&emsp;路由和负载均衡模块完全接管了nginx本身的策略，也是作为一个网关的核心功能。集群数据同步则弥补了nginx集群管理的缺点，可以使得路由规则和负载均衡策略的修改可以动态进行，省去了修改配置文件和重启的流程。       </p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;路由是Kong的核心功能之一。Kong会代理HTTP请求，根据HTTP主机头、请求URI和请求方式(GET/POST等)匹配路由规则，找到实际处理请求的后端服务。</p><p>&emsp;&emsp;Kong的路由规则由HTTP主机头、请求URI和请求方式组成。规则匹配发生在Nginx的Rewrite/Access阶段中，access_by_lua_block指令块里面的kong.access()方法的前置handler中。见<a href="https://github.com/cstoppgmr/material/blob/master/articles/APIGateway/nginx-kong.conf#L85" target="_blank" rel="noopener">kong-nginx.conf:85</a>  </p><p>&emsp;&emsp;路由规则的原始数据存储在数据库apis表中。HTTP主机头由表字段hosts描述、请求URI由表字段uris描述、请求方式由表字段methods描述。在MySQL中，这3个字段的数据存储格式都是JSON序列化之后字符串数组。apis的表结构描述如下： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`apis`</span> (</span><br><span class="line">  <span class="comment">-- guid</span></span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 名称</span></span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- upstream标识</span></span><br><span class="line">  <span class="string">`upstream_url`</span> <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 是否保留主机头</span></span><br><span class="line">  <span class="string">`preserve_host`</span> tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 主机头匹配</span></span><br><span class="line">  <span class="string">`hosts`</span> <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- uri匹配</span></span><br><span class="line">  <span class="string">`uris`</span> <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 请求方法匹配</span></span><br><span class="line">  <span class="string">`methods`</span> <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 是否只接受https的请求</span></span><br><span class="line">  <span class="string">`https_only`</span> tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="comment">-- 如果接受https的请求并且客户端IP不在授信IP中，是否终止请求</span></span><br><span class="line">  <span class="string">`http_if_terminated`</span> tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="comment">-- 由于链路问题(connection timeouts, connection resets等或者5xx错误)导致请求转发失败重试次数</span></span><br><span class="line">  <span class="string">`retries`</span> <span class="built_in">smallint</span>(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="string">'5'</span>,</span><br><span class="line">  <span class="comment">-- 如果是uri前缀匹配，是否剥离掉uri前缀</span></span><br><span class="line">  <span class="string">`strip_uri`</span> tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span>,</span><br><span class="line">  <span class="comment">-- 一些超时时间</span></span><br><span class="line">  <span class="string">`upstream_connect_timeout`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'60000'</span>,</span><br><span class="line">  <span class="string">`upstream_send_timeout`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'60000'</span>,</span><br><span class="line">  <span class="string">`upstream_read_timeout`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'60000'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`name`</span> (<span class="string">`name`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`apis_name_idx`</span> (<span class="string">`name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;路由规则的创建在Nginx的初始化阶段，init_by_lua_block指令块中的kong.init()方法里。见<a href="https://github.com/cstoppgmr/material/blob/master/articles/APIGateway/nginx-kong.conf#L26" target="_blank" rel="noopener">kong-nginx.conf:26</a>  </p><p>&emsp;&emsp;在kong.init()的末尾调用core.build_router(dao, “init”)方法构造路由表。见<a href="https://github.com/Kong/kong/blob/master/kong/init.lua#L174" target="_blank" rel="noopener">init.lua:174</a>。  </p><p>&emsp;&emsp;build_router方法的第一个参数是一个数据库操作对象，会使用它查询出数据库apis表中的数据。第二个参数是一个路由表在缓存中的版本号。如果apis表的数据发生变化，会触发缓存的invalidate操作，生成出一个新的version。此时在kong.access()方法中会再次调用build_router对路由表进行重建。见<a href="https://github.com/Kong/kong/blob/master/kong/core/handler.lua#L336" target="_blank" rel="noopener">handler.lua:336</a>。  </p><p>&emsp;&emsp;build_router会对从apis表中查询出来的数据按创建时间created_at从小到大进行排序。见<a href="https://github.com/Kong/kong/blob/master/kong/core/handler.lua#L54" target="_blank" rel="noopener">handler.lua:54</a>。这样如果2条规则相同的话较早的规则会优先匹配。接着会构造一个Router对象，它会负责路由表的创建、路由规则的匹配操作。  </p><h3 id="生成规则"><a href="#生成规则" class="headerlink" title="生成规则"></a>生成规则</h3><p>&emsp;&emsp;Router对象的第一个核心功能就是把数据库中的apis数据转化为适合进行匹配的规则。规则类型有3种：HOST、URI和METHOD，见<a href="https://github.com/Kong/kong/blob/master/kong/core/router.lua#L56" target="_blank" rel="noopener">router.lua:56</a>。这3种类型分别由位标识0x01、0x02和0x04表示。3种类型组成7种匹配方式：  </p><ul><li>HOST and URI and METHOD，位标识为(0x01 | 0x02 | 0x04) == 0x07</li><li>HOST and URI，位标识为(0x01 | 0x02) == 0x03</li><li>HOST and METHOD，位标识为(0x01 | 0x04) == 0x05</li><li>METHOD and URI，位标识为(0x04 | 0x02) == 0x06</li><li>HOST，位标识为0x01</li><li>URI，位标识为0x02</li><li>METHOD， 位标识为0x04  </li></ul><p>&emsp;&emsp;创建规则前会先把数据库里存储的apis对象格式化成api_t对象，api_t格式如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">api_t      = &#123;</span><br><span class="line">    <span class="comment">-- 数据库里面的apis对象</span></span><br><span class="line">    api            = api,</span><br><span class="line">    <span class="comment">-- 是否对URI按前缀进行剥离</span></span><br><span class="line">    strip_uri      = api.strip_uri,</span><br><span class="line">    <span class="comment">-- 请求转发的时候是否保留原始主机头</span></span><br><span class="line">    preserve_host  = api.preserve_host,</span><br><span class="line">    <span class="comment">-- 7种匹配方式的位标识</span></span><br><span class="line">    match_rules    = <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">-- 主机头匹配规则，当作数组使用</span></span><br><span class="line">    hosts          = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- uri匹配规则，当作数组使用</span></span><br><span class="line">    uris           = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- method匹配规则，当作词典使用</span></span><br><span class="line">    methods        = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- upstream信息</span></span><br><span class="line">    upstream_url_t = &#123;&#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果主机头匹配里面包含通配符，如：*.example.com，则把通配表达式转成正则表达式：.+\\.example\\.com$，然后hosts字段里面存储的对象格式为： </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    wildcard = <span class="literal">true</span>,</span><br><span class="line">    value    = <span class="string">'*.example.com'</span>,</span><br><span class="line">    regex    = <span class="string">'.+\\.example\\.com$'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果主机头匹配里面是普通的字符串，如：abc.example.com，那么hosts字段里面存储的对象格式为：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value    = abc.example.com,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用正则表达式：^[a-zA-Z0-9.-_~/%]*$ 判断uri匹配是否是一个普通的uri前缀。如果是，如：/prefix/some，则uris字段里面存储的对象格式为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    is_prefix = <span class="literal">true</span>,</span><br><span class="line">    value    = <span class="string">'/prefix/some'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;如果uri匹配是包含正则字符串，如：/users/\d+/profile，则uris字段里面存储的对象格式为：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    is_regex     = <span class="literal">true</span>,</span><br><span class="line">    value        = <span class="string">'/users/\d+/profile'</span>,</span><br><span class="line">    regex        = <span class="string">'/users/\d+/profile'</span>,</span><br><span class="line">    has_captures = <span class="literal">false</span>,</span><br><span class="line">    strip_regex  = <span class="string">'/users/\d+/profile/?(?&lt;stripped_uri&gt;.*)'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>&emsp;&emsp;如果method匹配是get方式，则会把get转成大写，如：GET，以此作为key放入methods词典中。</p><p>&emsp;&emsp;使用一个词典数据结构categories对api_t对象以7种匹配方式进行归类。词典的key为7种匹配方式的位标识：0x01、0x02、0x03、0x04、0x05、0x06、0x07，value里面会按host、uri和method对规则进行分组。value定义如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">-- 按host分组的规则，词典类型</span></span><br><span class="line">    apis_by_hosts   = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- 按uri分组的规则，词典类型</span></span><br><span class="line">    apis_by_uris    = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- 按method分组的规则，词典类型</span></span><br><span class="line">    apis_by_methods = &#123;&#125;,</span><br><span class="line">    <span class="comment">-- 该匹配模式下所有规则，数组类型</span></span><br><span class="line">    all             = &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;如果一个匹配规则是hosts=[abc.com]、uris=[/path]、method=[GET]，那么categories会包含此规则的api_t对象。如下所示：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">7</span> = &#123;</span><br><span class="line">      apis_by_hosts   = &#123;</span><br><span class="line">        abc.com = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_uris    = &#123;</span><br><span class="line">        /<span class="built_in">path</span> = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_methods = &#123;</span><br><span class="line">        GET = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      all             = [api_t对象],  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;如果另一个匹配规则是hosts=[abc.com]、uris=[/version]，那么categories会包含此规则的api_t对象2。如下所示：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">3</span> = &#123;</span><br><span class="line">      apis_by_hosts   = &#123;</span><br><span class="line">        abc.com = [api_t对象<span class="number">2</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_uris    = &#123;</span><br><span class="line">        /version = [api_t对象<span class="number">2</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">      all             = [api_t对象<span class="number">2</span>],  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">7</span> = &#123;</span><br><span class="line">      apis_by_hosts   = &#123;</span><br><span class="line">        abc.com = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_uris    = &#123;</span><br><span class="line">        /<span class="built_in">path</span> = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_methods = &#123;</span><br><span class="line">        GET = [api_t对象]</span><br><span class="line">        &#125;,</span><br><span class="line">      all             = [api_t对象],  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;另外使用一个词典数据结构plain_indexes和3个数组结构uris_prefixes、uris_regexes、和wildcard_hosts决定优先使用哪种匹配模式。它们的创建方式见<a href="https://github.com/Kong/kong/blob/master/kong/core/router.lua#L252" target="_blank" rel="noopener">router.lua:252</a>。首先会使用plain_indexes匹配主机头、uri和请求方法，因为它的构造是一个词典结构，可直接根据主机头、uri和请求方法进行查询，效率比较高。plain_indexes的内容如下： </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hosts = &#123;</span><br><span class="line">      abc.com   = <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    uris = &#123;</span><br><span class="line">      /foo = <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods = &#123;</span><br><span class="line">     GET = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>&emsp;&emsp;如果在plain_indexes里面没有查询到的话，则使用uris_prefixes、uris_regexes、和wildcard_hosts里面的规则一个一个进行匹配，直到匹配成功为止。</p><h3 id="匹配流程"><a href="#匹配流程" class="headerlink" title="匹配流程"></a>匹配流程</h3><p>&emsp;&emsp;规则的匹配在kong.access方法里面，调用router.exec方法进行匹配。见<a href="https://github.com/Kong/kong/blob/master/kong/core/handler.lua#L354" target="_blank" rel="noopener">handler.lua:354</a>。  </p><p>&emsp;&emsp;router.exec方法从http请求里面获取主机头信息、HTTP请求方法和请求URI。然后调用find_api方法进行实际地匹配。见<a href="https://github.com/Kong/kong/blob/master/kong/core/router.lua#L594" target="_blank" rel="noopener">router.lua:594</a>。   </p><p>&emsp;&emsp;find_api首先从缓存里面查询匹配结果。如果缓存里面没有数据，则是第一次匹配。先把请求中的主机头放入ctx.req_host，请求uri放入ctx.req_uri，请求方法放入ctx.req_method。然后使用plain_indexes、uris_prefixes、uris_regexes、和wildcard_hosts选择匹配模式。这里如果是根据uri前缀、uri正则表达式或主机头通配符匹配到的话，则会把uri前缀或uri正则表达式放入ctx.hits.uri中，把主机头通配符放入ctx.hits.host中。后续就使用ctx去和规则进行匹配。匹配模式按照CATEGORIES定义的顺序进行降级匹配。如果匹配模式是0x07，则使用0x07里面的规则去匹配。如果匹配失败，则使用0x03的规则进行匹配。如果还是失败，则继续按0x05 -&gt; 0x06 -&gt; 0x01 -&gt; 0x02 -&gt; 0x04的降级顺序进行匹配，直到成功为止。  </p><p>&emsp;&emsp;确定匹配模式之后，先使用reduce方法对候选的规则进行筛选。前面说到每一种匹配模式包含的规则会按host、uri和method进行分组。reduce方法就是选取数量最少的那个分组。如果那个分组下的规则匹配失败，则使用all下面的规则进行匹配。  </p><p>&emsp;&emsp;现在举例说明。假设现在根据如下json创建了一个apis对象。  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"my-api"</span>,</span><br><span class="line">    <span class="attr">"upstream_url"</span>: <span class="string">"http://my-api.com"</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"example.com"</span>, <span class="string">"service.com"</span>],</span><br><span class="line">    <span class="attr">"uris"</span>: [<span class="string">"/foo"</span>, <span class="string">"/bar"</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"GET"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;对应的api_t内容是：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">api_t      = &#123;</span><br><span class="line">    api            = 数据库中的api对象,</span><br><span class="line">    strip_uri      = <span class="literal">false</span>,</span><br><span class="line">    preserve_host  = <span class="literal">false</span>,</span><br><span class="line">    match_rules    = <span class="number">0x07</span>,</span><br><span class="line">    hosts          = [</span><br><span class="line">                      &#123;</span><br><span class="line">                                value    = example.com,</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                                value    = service.com,</span><br><span class="line">                      &#125;</span><br><span class="line">    ],</span><br><span class="line">    uris           = [</span><br><span class="line">                      &#123;</span><br><span class="line">                                is_prefix = <span class="literal">true</span>,</span><br><span class="line">                                value    = <span class="string">'/foo'</span>,  </span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                                is_prefix = <span class="literal">true</span>,</span><br><span class="line">                                value    = <span class="string">'/bar'</span>,  </span><br><span class="line">                      &#125;</span><br><span class="line">    ],</span><br><span class="line">    methods        = &#123;GET = <span class="literal">true</span>&#125;,</span><br><span class="line">    upstream_url_t = &#123;</span><br><span class="line">                         scheme             = http,</span><br><span class="line">                         host               = my-api.com,</span><br><span class="line">                         port               = <span class="number">80</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>  <p>&emsp;&emsp;categories内容如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">7</span> = &#123;</span><br><span class="line">      apis_by_hosts   = &#123;</span><br><span class="line">        example.com = [api_t],</span><br><span class="line">        service.com = [api_t]</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_uris    = &#123;</span><br><span class="line">        /foo = [api_t],</span><br><span class="line">        /bar = [api_t],</span><br><span class="line">        &#125;,</span><br><span class="line">      apis_by_methods = &#123;</span><br><span class="line">        GET = [api_t]</span><br><span class="line">        &#125;,</span><br><span class="line">      all             = [api_t],  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;plain_indexes的内容如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hosts = &#123;</span><br><span class="line">      example.com   = <span class="literal">true</span>,</span><br><span class="line">      service.com   = <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    uris = &#123;</span><br><span class="line">      /foo = <span class="literal">true</span>,</span><br><span class="line">      /bar = <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods = &#123;</span><br><span class="line">     GET = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;uris_prefixes的内容如下：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      is_prefix = <span class="literal">true</span>,</span><br><span class="line">      value    = <span class="string">'/foo'</span>,  </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      is_prefix = <span class="literal">true</span>,</span><br><span class="line">      value    = <span class="string">'/bar'</span>,  </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;由于host匹配没有通配符以及uri匹配没有正则表达式，所以uris_regexes和wildcard_hosts为空。  </p><p>&emsp;&emsp;假设现在有如下请求：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/<span class="number">1.1</span></span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;此请求的主机头是example.com，请求uri是/foo，请求方法是GET。首先使用plain_indexes确定匹配模式为0x07，因为plain_indexes.hosts包含example.com，位标识是0x01。plain_indexes.uris包含/foo，位标识是0x02。plain_indexes.methods包含GET，位标识是0x04。把0x01，0x02和0x04通过位或运算得到0x07。  </p><p>&emsp;&emsp;根据0x07从categories里选择key为7的规则。reduce方法等价于:<br><code>min(#categories[7].apis_by_hosts[example.com], #categories[7].apis_by_uris[/foo], #categories[7].apis_by_methods[GET])</code><br>&emsp;&emsp;#号是取数组的长度。此处这3个数组的长度都是1，所以优先选择apis_by_hosts中的api_t规则进行匹配。  api_t里面的hosts、uris和methods匹配上了这个请求，此次匹配成功。  </p><h2 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h2><h3 id="概览-2"><a href="#概览-2" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;Balancer对请求做负载均衡，使请求分散地转发到后端服务。从而可以优化资源利用率、提升吞吐量、减少延时以及提高容错等。Kong使用了DNS-Balancer和Ring-Balancer两种均衡模式。DNS-Balancer适合对外部的第三方服务进行负载均衡。候选服务器列表添加在A记录或SRV记录中。A记录中只包含IP地址，而且没有权重信息，适合简单的round-robin。SRV记录中包含IP地址和端口，并含有权重信息，可以按权重调拨流量以及IP地址复用。Ring-Balancer适合对内部服务进行负载运行。因为这种模式的控制性强，可以灵活地支持机器上下线操作、带权重的负载均衡以及可以进行蓝绿部署和金丝雀发布。本章着重分析Ring模式。  </p><h3 id="Ring-Balancer"><a href="#Ring-Balancer" class="headerlink" title="Ring-Balancer"></a>Ring-Balancer</h3><p>&emsp;&emsp;在Kong里面，Ring-Balancer通过upstream和target对象描述。upstream对象用于调节负载均衡的行为，如权重分配、健康检查以及是否通过一致性hash绑定请求到对应的机器上。target存储进行负载均衡的机器列表。  </p><p>&emsp;&emsp;upstream对象数据库表结构描述如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> upstreams (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 槽位大小，用于调节权重</span></span><br><span class="line">  slots <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- json格式存储的健康检查配置</span></span><br><span class="line">  healthchecks <span class="built_in">varchar</span>(<span class="number">10000</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 首选hash输入值：none,consumer,ip,header</span></span><br><span class="line">  hash_on <span class="built_in">varchar</span>(<span class="number">31</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 此选hash输入值</span></span><br><span class="line">  hash_fallback <span class="built_in">varchar</span>(<span class="number">31</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 根据http header进行hash时，首选的header</span></span><br><span class="line">  hash_on_header <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 此选的header</span></span><br><span class="line">  hash_fallback_header <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  created_at <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="keyword">name</span> (<span class="keyword">name</span>),</span><br><span class="line">  <span class="keyword">KEY</span> upstreams_name_idx (<span class="keyword">name</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;target对象数据库表结构描述如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> targets (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- ip:port</span></span><br><span class="line">  target <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 权重值</span></span><br><span class="line">  weight <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 所属upstream</span></span><br><span class="line">  upstream_id <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  created_at <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">KEY</span> tragets_upstreamid_fk (upstream_id),</span><br><span class="line">  <span class="keyword">KEY</span> targets_target_idx (target),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> tragets_upstreamid_fk FOREIGN <span class="keyword">KEY</span> (upstream_id) <span class="keyword">REFERENCES</span> upstreams (<span class="keyword">id</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure> <h4 id="构造balancer"><a href="#构造balancer" class="headerlink" title="构造balancer"></a>构造balancer</h4><p>&emsp;&emsp;Ring-Balancer的初始化发生在nginx工作进程的初始化阶段中，init_worker_by_lua_block指令块的kong.init_worker()方法里，见<a href="https://github.com/cstoppgmr/material/blob/master/articles/APIGateway/nginx-kong.conf#L30" target="_blank" rel="noopener">nginx-kong.conf:30</a>。init_worker里面调用了balancer.init()方法做了实际的初始化工作。  </p><p>&emsp;&emsp;balancer.init首先使用get_all_upstreams方法从数据库upstreams表加载所有数据到缓存中。调用create_balancer方法对每个查询出来的upstream对象，创建一个负载均衡器ring_balancer。均衡器的实现在resty.dns.balancer模块中，这个模块在Kong的lua-resty-dns-client项目里，代码见<a href="https://github.com/Kong/lua-resty-dns-client" target="_blank" rel="noopener">github</a>，文档见<a href="https://kong.github.io/lua-resty-dns-client/modules/resty.dns.balancer.html" target="_blank" rel="noopener">resty.dns.balancer</a>。  </p><p>&emsp;&emsp;均衡器初始化使用了3个参数：wheelSize,order和dns，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L295" target="_blank" rel="noopener">balancer.lua:295</a>。在0.12.1版本中，实际使用的就wheelSize这一个参数。如果wheelSize越大，目标机器的分布就越离散。这样在选择的时候既可以保证权重，连续选到相同的机器的概率也比较小。当然wheelSize越大，占用的内存就越多，重建的开销比较大。可以根据后端机器的数量选择的一个值，它的默认值是1000。  </p><h4 id="加载target"><a href="#加载target" class="headerlink" title="加载target"></a>加载target</h4><p>&emsp;&emsp;fetch_target_history方法会从key为balancer:targets:${upstreamId}的缓存中选择upstream下面的target，如果缓存中没有就调用load_targets_into_memory方法从数据库中查询出来再放入缓存。<br>&emsp;&emsp;Kong的api没有对target按ip和端口进行修改的操作。(这是因为如果只是做添加操作的话，可以不重建balancer，减少开销，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L364" target="_blank" rel="noopener">balancer.lua:364</a>。但是在check_target_history方法中有一个bug，导致即使只是添加target，还是会重建balancer，bug见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L357" target="_blank" rel="noopener">balancer.lua:357</a>，这里把old_history和new_history写反了。)<br>&emsp;&emsp;由于只做添加，数据库表targets中可能会出现多条target相同的数据(ip和port相同)，但是权重是不同的数据。如果出现这种情况该决定使用哪个target记录呢?fetch_target_history方法会对查询出来的target记录按创建时间进行从老到新的排序，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L116" target="_blank" rel="noopener">balancer.lua:116</a>。之后apply_history方法会按这个顺序把target添加到均衡器ring_balancer中，如果ip和端口相同，ring_balancer中后添加的记录会覆盖之前的，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L314" target="_blank" rel="noopener">balancer.lua:314</a>。 </p><p>&emsp;&emsp;无论是Ring-Balancer或DNS-Balancer，都是使用resty.dns.balancer这个负载均衡器做的负载均衡。这是因为在调用resty.dns.balancer的addHost方式时。如果hostname传的是域名的话，会做dns解析，把解析出来的节点添加进去。但如果hostname是ip地址的话，直接把添加参数所表示的节点。文档见<a href="https://kong.github.io/lua-resty-dns-client/modules/resty.dns.balancer.html#addHost" target="_blank" rel="noopener">addHost</a></p><h4 id="target健康检查"><a href="#target健康检查" class="headerlink" title="target健康检查"></a>target健康检查</h4><p>&emsp;&emsp;create_healthchecker方法为每个负载均衡器ring_balancer添加健康检查。<br>健康检查的实现在resty.healthcheck模块中，这个模块在Kong的lua-resty-healthcheck项目里，代码见<a href="https://github.com/Kong/lua-resty-healthcheck" target="_blank" rel="noopener">github</a>，文档见<a href="https://kong.github.io/lua-resty-healthcheck/modules/resty.healthcheck.html" target="_blank" rel="noopener">resty.healthcheck</a>。<br>&emsp;&emsp;create_healthchecker使用如下代码构造健康检查器：  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> healthchecker, err = healthcheck.new(&#123;</span><br><span class="line">   name = upstream.name,</span><br><span class="line">   shm_name = <span class="string">"kong_healthchecks"</span>,</span><br><span class="line">   checks = upstream.healthchecks,</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;shm_name传递的是lua-resty-healthcheck需要的nginx中的共享内存名，用于存储当前哪些节点的失败或成功次数。定义见<a href="https://github.com/cstoppgmr/material/blob/master/articles/APIGateway/nginx-kong.conf#L21" target="_blank" rel="noopener">nginx-conf:21</a>。</p><p>&emsp;&emsp;checks传递的是健康检查的json配置。健康检查有主动检查和被动检查2种。  </p><p>&emsp;&emsp;主动检查需要设置检查url、超时时间、检查间隔、失败判断码、失败判断次数、成功判断码、成功判断次数、超时判断次数等。<br>&emsp;&emsp;kong默认的主动检查配置如下(这个配置不会启用主动检查，因为tcp_failures、timeouts、http_failures、interval和successes都被设成了0)：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">"active":&#123;</span><br><span class="line">    "unhealthy":&#123;</span><br><span class="line">        "http_statuses":[</span><br><span class="line">            429,</span><br><span class="line">            404,</span><br><span class="line">            500,</span><br><span class="line">            501,</span><br><span class="line">            502,</span><br><span class="line">            503,</span><br><span class="line">            504,</span><br><span class="line">            <span class="number">505</span></span><br><span class="line">        ],</span><br><span class="line">        "tcp_failures":0,</span><br><span class="line">        "timeouts":0,</span><br><span class="line">        "http_failures":0,</span><br><span class="line">        "interval":0</span><br><span class="line">    &#125;,</span><br><span class="line">    "http_path":"/",</span><br><span class="line">    "timeout":1,</span><br><span class="line">    "healthy":&#123;</span><br><span class="line">        "http_statuses":[</span><br><span class="line">            200,</span><br><span class="line">            <span class="number">302</span></span><br><span class="line">        ],</span><br><span class="line">        "interval":0,</span><br><span class="line">        "successes":0</span><br><span class="line">    &#125;,</span><br><span class="line">    "concurrency":10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;kong会根据配置定期对后端服务节点机器调用检查url进行检查，如果检查超时或HTTP返回码满足失败条件的次数超过限制，负载均衡器会把该节点标记为不可用。 </p><p>&emsp;&emsp;被动检查需要设置失败判断码、失败判断次数、成功判断码、成功判断次数、超时判断次数等。<br>&emsp;&emsp;kong默认的被动检查配置如下(这个配置不会启用被动检查，因为tcp_failures、timeouts、http_failures和successes都被设成了0)：  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">"passive":&#123;</span><br><span class="line">    "unhealthy":&#123;</span><br><span class="line">        "http_failures":0,</span><br><span class="line">        "http_statuses":[</span><br><span class="line">            429,</span><br><span class="line">            500,</span><br><span class="line">            <span class="number">503</span></span><br><span class="line">        ],</span><br><span class="line">        "tcp_failures":0,</span><br><span class="line">        "timeouts":0</span><br><span class="line">    &#125;,</span><br><span class="line">    "healthy":&#123;</span><br><span class="line">        "http_statuses":[</span><br><span class="line">            200,</span><br><span class="line">            201,</span><br><span class="line">            202,</span><br><span class="line">            203,</span><br><span class="line">            204,</span><br><span class="line">            205,</span><br><span class="line">            206,</span><br><span class="line">            207,</span><br><span class="line">            208,</span><br><span class="line">            226,</span><br><span class="line">            300,</span><br><span class="line">            301,</span><br><span class="line">            302,</span><br><span class="line">            303,</span><br><span class="line">            304,</span><br><span class="line">            305,</span><br><span class="line">            306,</span><br><span class="line">            307,</span><br><span class="line">            <span class="number">308</span></span><br><span class="line">        ],</span><br><span class="line">        "successes":0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;kong在跟后端机器进行通信的过程中，判断其返回码，有无超时。然后根据配置决定是否对节点进行标记。     </p><p>&emsp;&emsp;由于被动检查的操作是在负载均衡器里面进行，attach_healthchecker_to_balancer里面对负载均衡器设置了report_http_status和report_tcp_failure方法，这2个方法会在转发请求的时候被调用，把请求结果通知给健康检查器，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L249" target="_blank" rel="noopener">balancer.lua:249</a>。<br>&emsp;&emsp;这里要注意下如果被动检查把一个节点标记为不可用的话，即使该节点已经恢复了，kong也不会自动地把该节点添加进balancer中。需要用户手动调用一个管理接口进行恢复，见<a href="https://getkong.org/docs/0.12.x/health-checks-circuit-breakers/#passive-health-checks-circuit-breakers" target="_blank" rel="noopener">文档</a>。  </p><p>&emsp;&emsp;构造完健康检查器后，调用populate_healthchecker方法把负载均衡器中节点添加到健康检查器中。然后调用attach_healthchecker_to_balancer监听健康检查器的事件：healthchecker.events.healthy和healthchecker.events.unhealthy，并设置回调方法。回调方法就是根据健康检查器的事件类型，在负载均衡器中把后端节点标记为可用或不可用，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L229" target="_blank" rel="noopener">balancer.lua:229</a>。 </p><h4 id="选择target"><a href="#选择target" class="headerlink" title="选择target"></a>选择target</h4><p>&emsp;&emsp;当请求匹配出一条路由规则之后，就会在该规则下面的target中选一个目标实例进行转发。目标实例的选择发生在kong.access()的后置handler中，调用balancer.execute方式进行选择。target的选择全权委托给了resty.dns.balancer对象，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/balancer.lua#L689" target="_blank" rel="noopener">balancer.lua:689</a>。<br>&emsp;&emsp;选择target的算法是带权重的round-robins。普通的round-robins算法把所有候选的target放入一个数组中，确定一个数组的起始元素(一般取第一个)。之后每次选择的时候按顺序往后选一个，到末尾时再从头开始遍历。带权重的round-robins算法相似，也是遍历数组。只不过数组的大小会远远超过target的数量，resty.dns.balancer初始化的时候wheelSize就是指定这个数组的大小。wheelSize和每个target的权重值确定一个target在数组中分配的数量，然后随机选择数组的位置进行放入。</p><h2 id="集群间数据同步"><a href="#集群间数据同步" class="headerlink" title="集群间数据同步"></a>集群间数据同步</h2><h3 id="概览-3"><a href="#概览-3" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;kong的代码运行于nginx的worker进程中。kong对数据的修改会在一个worker中进行，数据被修改后需要通知给本地的其他worker进程和其他机器上的worker进程。kong使用的进程间通信主要方式有：1. 本机间通信-共享内存 2. 跨机器通信-数据库。  </p><h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p>&emsp;&emsp;kong的数据存储在数据库中，同时在缓存中保留一份。当数据库的中的数据被修改时，需要发出相应的事件通知其他worker。其他worker接收事件后，删除缓存中对应的数据。下次从缓存读数据时发现没有的话，就从数据库加载出来。<br>&emsp;&emsp;事件分为本地事件和集群事件。本地事件用于通知在一台机器上的worker，集群事件用于通知在多台机器上的worker。</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>&emsp;&emsp;本地事件通过共享内存实现。kong实现了一套基于nginx共享内存的事件发布-订阅机制，源码见仓库<a href="https://github.com/Kong/lua-resty-worker-events" target="_blank" rel="noopener">lua-resty-worker-events</a>。该包提供post_local方法在worker进程内进行事件发布，提供post方法在同属于一台机器上的worker进程间进行事件发布。这2个方法需要指定source和event来确定事件源。<br>&emsp;&emsp;kong的数据访问层<a href="https://github.com/Kong/kong/blob/0.12.1/kong/dao/dao.lua" target="_blank" rel="noopener">dao.lua</a>封装了insert、update和delete三个对数据操作的方法。这三个方法分别会使用post_local发出source为dao:crud，event为insert、delete、update的数据增、删、改的事件。事件的数据格式如下:  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   schema    = self.schema, <span class="comment">--表名</span></span><br><span class="line">   operation = <span class="string">"create"</span>, <span class="comment">--操作类型</span></span><br><span class="line">   entity    = res, <span class="comment">--数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>&emsp;&emsp;worker进程启动的时候会在init_worker阶段注册这些事件的订阅方法，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/handler.lua#L97" target="_blank" rel="noopener">handler.lua:97</a>。订阅方法中把所有的dao:crud事件按表名称使用post_local再进行分发。所以从dao:crud分发的事件如下:  </p><ul><li>source=crud, event=apis<br>这个事件会通知所有的worker(包含不同机器)apis数据的修改。这里对缓存中对key为router:version进行invalidate操作会发送一条channel=invalidations集群事件。  </li><li>source=crud, event=targets<br>这个事件会通知所有的worker(包含不同机器)targets数据的修改。使用cluster_events:broadcast方法发送一条channel=balancer:targets集群事件。</li><li>source=crud, event=upstreams<br>这个事件会通知所有的worker(包含不同机器)upstreams数据的修改。使用cluster_events:broadcast方法发送一条channel=balancer:upstreams集群事件。</li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>&emsp;&emsp;集群事件通过数据库实现。数据库表cluster_events存放用于集群间分发的事件。cluster_events表结构如下:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cluster_events (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 标识生成事件的节点id</span></span><br><span class="line">  node_id <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件产生时间，精确到毫秒 </span></span><br><span class="line">  <span class="keyword">at</span> <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件生效时间，精确到毫秒</span></span><br><span class="line">  nbf <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件过期时间，精确到毫秒</span></span><br><span class="line">  expire_at <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件类型</span></span><br><span class="line">  channel <span class="built_in">varchar</span>(<span class="number">1023</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 事件数据</span></span><br><span class="line">  <span class="keyword">data</span> <span class="built_in">varchar</span>(<span class="number">10000</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">KEY</span> cluster_events_at_idx (<span class="keyword">at</span>),</span><br><span class="line">  <span class="keyword">KEY</span> cluster_events_channelt_idx (channel)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure> <p>channel的类型有:  </p><ul><li>invalidations<br>表示路由规则、插件配置的变更</li><li>balancer:targets<br>表示负载均衡的targets列表发生变更</li><li>balancer:upstreams<br>表示upstream对象发生变更</li><li>balancer:post_health<br>表示target的健康状态发生变更。由于被动健康检查拉出实例后，kong不会在对该实例进行自动拉入，需要通过该事件来拉入实例。  </li></ul><p>&emsp;&emsp;调用cluster_events:broadcast方法会往cluster_events表中新增一条记录。在init_worker阶段通过调用cluster_events:subscribe会开启一个定时器，定时查询出cluster_events表中新增的记录。这里要注意的是同一台机器上只会有一个worker进程会对数据库进行查询(通过加锁实现，代码见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/cluster_events.lua#L303" target="_blank" rel="noopener">cluster_events:303</a>)，查询出来后再通过共享内存的方式通知给这台机器上的其他worker。<br>&emsp;&emsp;配置参数db_update_frequency确定查询数据库的间隔，默认为5秒。数据范围根据at字段是否落在(起始时间, 结束时间]确定。起始时间第一次设置在init_worker阶段，调用ngx.now()获取当前时间(精确到毫秒)并放入key为cluster_events:at的共享内存中。之后抢到锁的worker会从共享内存中取出该时间，该时间需要减去db_update_propagation + 0.001来确定起始时间，以防止事件丢失。配置参数db_update_propagation默认为0。结束时间取ngx.now()的值。查询成功后会把结束时间覆盖之前的起始时间，并把该事件分发到本机的其他worker。对于设置了nbf的事件，kong如果发现还没到生效时间，就会通过ngx.timer设置一个定时器延后分发该事件。  </p><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><h3 id="概览-4"><a href="#概览-4" class="headerlink" title="概览"></a>概览</h3><p>&emsp;&emsp;kong的插件可以在不修改kong本身源码的情况下方便地添加一些功能。插件不仅可以处理请求，还可以定义API，操作数据库。kong本身提供了许多插件，支持鉴权认证、安全控制、流量调控和请求报文转换等。见<a href="https://konghq.com/plugins/" target="_blank" rel="noopener">plugins list</a>   </p><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p>&emsp;&emsp;每个插件都需要放置在plugins目录下。这里有个<a href="https://github.com/Kong/kong/blob/0.12.1/kong/plugins/base_plugin.lua" target="_blank" rel="noopener">base_plugin.lua</a>文件，定义了一个每个插件都需要去继承的基类。该基类定义了一些每个子类都需要去实现的方法，kong在每个执行阶段会调用。插件需要定义一个handler.lua文件，在这个文件里面去实现子类。此外还需要定义一个schema.lua文件，在这里定义每个插件的配置数据。<br>&emsp;&emsp;在nginx的master启动阶段，会扫描plugins目录下面的所有插件，加载handler.lua和schema.lua中定义的模块，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/init.lua#L78" target="_blank" rel="noopener">kong/init.lua:78</a>。<br>&emsp;&emsp;数据库中的plugins表定义了需要启用的插件。只有在这张表里面存在的插件，并且是开启状态的才会被使用。<br>&emsp;&emsp;插件还可以定义一个api.lua文件，用于暴露一些api接口。如oauth2插件。kong在nginx的配置文件里面开启了8001端口，所有的管理api都暴露在这个端口上。它会调用kong/init.lua中的serve_admin_api方法，使用lapis模块加载api/routes/init.lua，初始化管理接口。这里也会加载插件的api.lua，加载插件的接口，见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/api/init.lua#L158" target="_blank" rel="noopener">api/init.lua:158</a>。<br>&emsp;&emsp;在每个请求的执行阶段，都会先执行kong的前置处理方法，然后遍历所有启用的插件执行每个阶段对应的方法。如果读者看过base_plugin的文件话会发现基本上所有的方法都会传一个conf参数。这个就是在plugins表中定义的每个插件需要用到的配置。遍历插件的时候会从缓存里面加载插件配置，如果缓存失效就会从数据里面重新加载一遍。我们可以触发invalidations集群事件来动态的更新插件配置。见<a href="https://github.com/Kong/kong/blob/0.12.1/kong/core/plugins_iterator.lua" target="_blank" rel="noopener">core/plugins_iterator.lua</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;kong是一个基于nginx和OpenResty模块构建的API网关服务。提供http请求路由，后端服务负载均衡以及通过丰富的插件提供认证鉴权、流量调控、日志监控等功能。该网关目前应用在全球著名的API管理站点&lt;a href=&quot;https://market.mashape.com/explore?page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mashape&lt;/a&gt;上。&lt;br&gt;&amp;emsp;&amp;emsp;nginx是一个采用异步I/O，事件驱动的高性能Web服务器，也可以作为在企业内部提供基于http rpc的反向代理和负载均衡器。由于nginx的配置都是以静态文件的方式提供，而且nginx一般都是多台部署，导致nginx的运维管理变得比较复杂。许多运维的小伙伴都会写一些运维脚本，自动通过ssh命令远程连接到服务器去做一些配置更新的操作。&lt;br&gt;&amp;emsp;&amp;emsp;笔者所在公司也开发过一个基于nginx的软负载中心。用户可以在平台上为自己的服务配置反向代理以及负载均衡策略。用户所有的操作都会打包成一次对nginx配置的修改。修改指令会发送到每台nginx部署的一个agent上，最后由agent完成nginx配置文件的更新。&lt;br&gt;&amp;emsp;&amp;emsp;这些方法虽然可以达到自动化的管理nginx，但是本质上还是通过配置文件的方式去改变nginx的一些固定行为。在企业里面，特别是互联网公司常常需要定制一些功能。虽然可以为nginx开发一些模块，但是门槛较高，需要对nginx源码级的掌握。OpenResty为nginx引入的LuaJIT和lua-nginx-module，使我们可以在nginx的各个执行阶段编写一些lua脚本，极大地扩展了nginx的功能。OpenResty的作者已经用lua开发了许多工具库，使得我们可以在nginx中访问MySQL、Memcached、Redis。kong在此基础上实现了一个API网关服务。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://jinfei21.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="API网关" scheme="https://jinfei21.github.io/tags/API%E7%BD%91%E5%85%B3/"/>
    
      <category term="nginx" scheme="https://jinfei21.github.io/tags/nginx/"/>
    
      <category term="openresty" scheme="https://jinfei21.github.io/tags/openresty/"/>
    
      <category term="kong" scheme="https://jinfei21.github.io/tags/kong/"/>
    
      <category term="lua" scheme="https://jinfei21.github.io/tags/lua/"/>
    
  </entry>
  
</feed>
